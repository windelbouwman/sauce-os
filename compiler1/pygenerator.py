"""Generate python code

Idea: Use python code as bootstrapping target!

"""

import logging
import contextlib

from . import ast

logger = logging.getLogger("slangc.py-gencode")


def gen_pycode(modules: list[ast.Module], f):
    """Spit out python runable code"""
    logger.info("Generating python code")
    g = PyCodeGenerator(f)
    g.gen_header()
    g.gen_modules(modules)
    g.emit("if __name__ == '__main__':")
    with g.indented():
        g.emit("import sys")
        g.emit("sys.exit(main())")


class PyCodeGenerator:
    def __init__(self, f):
        self._level = 0
        self._f = f
        self.global_names = []

    def gen_header(self):
        self.emit("# Autogenerated python code!")
        self.emit("")

    def gen_modules(self, modules):
        for module in modules:
            for definition in module.definitions:
                if isinstance(definition, ast.VarDef):
                    self.global_names.append(self.gen_id(definition.id))
            for definition in module.definitions:
                self.gen_definition(module.name, definition)

    def gen_definition(self, modname, definition: ast.Definition):
        if isinstance(definition, ast.FunctionDef):
            self.gen_func(definition)
        elif isinstance(definition, ast.StructDef):
            assert not definition.is_union
            self.emit(f"class {self.gen_id(definition.id)}:")
            self.indent()
            field_names = [f"f_{field.id.name}" for field in definition.fields]
            args = ", ".join(field_names)
            self.emit(f"def __init__(self, {args}):")
            with self.indented():
                for field_name in field_names:
                    self.emit(f"self.{field_name} = {field_name}")
            self.dedent()
        elif isinstance(definition, ast.ExternFunction):
            self.emit(f"from slangrt import {modname}_{definition.id.name}")
        elif isinstance(definition, ast.VarDef):
            self.emit(
                f"{self.gen_id(definition.id)} = {self.gen_expression(definition.value)}"
            )
        else:
            raise NotImplementedError(str(definition))

    def gen_func(self, func_def: ast.FunctionDef):
        if func_def.parameters:
            params = ", ".join([self.gen_id(p.id) for p in func_def.parameters])
        else:
            params = ""
        self.emit(f"def {self.gen_id(func_def.id)}({params}):")
        self.indent()
        if self.global_names:
            global_decl = ", ".join(self.global_names)
            self.emit(f"global {global_decl}")

        if func_def.statement.ty.is_void() or func_def.statement.ty.is_unreachable():
            self.gen_statement(func_def.statement, None)
        else:
            res = "__slang_snag"
            self.gen_statement(func_def.statement, res)
            self.emit(f"return {res}")
        self.dedent()
        self.emit("")

    def gen_block(self, block: ast.ScopedBlock, target):
        with self.indented():
            self.gen_statement(block.body, target)

    def gen_statement(self, statement: ast.Statement, target):
        kind = statement.kind
        if isinstance(kind, ast.LetStatement):
            varname = self.gen_id(kind.variable.id)
            if isinstance(kind.value.kind, ast.StatementExpression):
                self.gen_statement(kind.value.kind.statement, varname)
            else:
                val = self.gen_expression(kind.value)
                self.emit(f"{varname} = {val}")
        elif isinstance(kind, ast.CompoundStatement):
            for statement in kind.statements[:-1]:
                self.gen_statement(statement, None)
            self.gen_statement(kind.statements[-1], target)
        elif isinstance(kind, ast.IfStatement):
            self.gen_if_statement(kind, "if", target)
        elif isinstance(kind, ast.WhileStatement):
            val = self.gen_expression(kind.condition, parens=False)
            self.emit(f"while {val}:")
            self.gen_block(kind.block, None)
        elif isinstance(kind, ast.TryStatement):
            self.emit("try:")
            self.gen_block(kind.try_block, None)
            parameter_name = self.gen_id(kind.parameter.id)
            ex_name = f"ex_{parameter_name}"
            self.emit(f"except ValueError as {ex_name}:")
            self.indent()
            self.emit(f"{parameter_name} = {ex_name}.args[0]")
            self.gen_statement(kind.except_block.body, None)
            self.dedent()
        elif isinstance(kind, ast.BreakStatement):
            self.emit("break")
        elif isinstance(kind, ast.ContinueStatement):
            self.emit("continue")
        elif isinstance(kind, ast.PassStatement):
            self.emit("pass")
        elif isinstance(kind, ast.UnreachableStatement):
            self.emit("raise RuntimeError('unreachable')")
        elif isinstance(kind, ast.AssignmentStatement):
            target = self.gen_expression(kind.target)
            val = self.gen_expression(kind.value, parens=False)
            op = kind.op
            self.emit(f"{target} {op} {val}")
        elif isinstance(kind, ast.ExpressionStatement):
            x = self.gen_expression(kind.value)
            if kind.value.ty.is_void() or kind.value.ty.is_unreachable():
                self.emit(x)
            else:
                assert target
                self.emit(f"{target} = {x}")
        elif isinstance(kind, ast.RaiseStatement):
            self.emit(
                f"raise ValueError({self.gen_expression(kind.value, parens=False)})"
            )
        elif isinstance(kind, ast.ReturnStatement):
            if kind.value:
                self.emit(f"return {self.gen_expression(kind.value, parens=False)}")
            else:
                self.emit("return")
        else:
            raise NotImplementedError(str(kind))

    def gen_if_statement(self, if_statement: ast.IfStatement, kw: str, target):
        val = self.gen_expression(if_statement.condition, parens=False)
        self.emit(f"{kw} {val}:")
        self.gen_block(if_statement.true_block, target)
        if isinstance(if_statement.false_block.body.kind, ast.IfStatement):
            # We got el-if!
            self.gen_if_statement(if_statement.false_block.body.kind, "elif", target)
        elif isinstance(if_statement.false_block.body.kind, ast.PassStatement):
            pass
        else:
            self.emit("else:")
            self.gen_block(if_statement.false_block, target)

    def gen_expression(self, expression: ast.Expression, parens: bool = True) -> str:
        kind = expression.kind
        if isinstance(kind, ast.StringConstant):
            return repr(kind.text)
        elif isinstance(kind, ast.CharConstant):
            return repr(kind.text)
        elif isinstance(kind, ast.NumericConstant):
            return f"{kind.value}"
        elif isinstance(kind, ast.BoolLiteral):
            return f"{kind.value}"
        elif isinstance(kind, ast.ArrayLiteral):
            values = self.gen_expressions(kind.values)
            return f"[{values}]"
        elif isinstance(kind, ast.ArrayLiteral2):
            size = self.gen_expression(kind.size)
            return f"[None] * {size}"
        elif isinstance(kind, ast.ArrayIndex):
            assert len(kind.indici) == 1
            base = self.gen_expression(kind.base)
            index = self.gen_expression(kind.indici[0])
            return f"{base}[{index}]"
        elif isinstance(kind, ast.DotOperator):
            base = self.gen_expression(kind.base)
            return f"{base}.f_{kind.field}"
        elif isinstance(kind, ast.StructLiteral):
            name = self.gen_id(kind.ty.kind.tycon.id)
            values = self.gen_expressions(kind.values)
            return f"{name}({values})"
        elif isinstance(kind, ast.Binop):
            lhs = self.gen_expression(kind.lhs)
            rhs = self.gen_expression(kind.rhs)
            if expression.ty.is_int() and kind.op == "/":
                op = "//"
            else:
                op = kind.op
            res = f"{lhs} {op} {rhs}"
            return f"({res})" if parens else res
        elif isinstance(kind, ast.Unop):
            rhs = self.gen_expression(kind.rhs)
            res = f"{kind.op} {rhs}"
            return f"({res})" if parens else res
        elif isinstance(kind, ast.ObjRef):
            obj = kind.obj
            if isinstance(
                obj, (ast.Variable, ast.FunctionDef, ast.Parameter, ast.VarDef)
            ):
                return self.gen_id(obj.id)
            elif isinstance(obj, ast.ExternFunction):
                modname = obj.modname
                return f"{modname}_{obj.id.name}"
            else:
                raise NotImplementedError(str(obj))
        elif isinstance(kind, ast.TypeCast):
            # TODO!
            return self.gen_expression(kind.value)
        elif isinstance(kind, ast.Box):
            return self.gen_expression(kind.value)
        elif isinstance(kind, ast.Unbox):
            return self.gen_expression(kind.value)
        elif isinstance(kind, ast.FunctionCall):
            callee = self.gen_expression(kind.target)
            args = self.gen_expressions([a.value for a in kind.args])
            return f"{callee}({args})"
        elif isinstance(kind, ast.StatementExpression):
            raise RuntimeError("Cannot generate statement expression on the stack")
        else:
            raise NotImplementedError(str(kind))

    def gen_expressions(self, values):
        return ", ".join([self.gen_expression(value, parens=False) for value in values])

    def gen_id(self, id: ast.Id):
        if id.name == "main":
            return "main"
        return f"X{id.id}_{id.name}"

    def indent(self):
        self._level += 1

    def dedent(self):
        self._level -= 1

    @contextlib.contextmanager
    def indented(self):
        self.indent()
        yield
        self.dedent()

    def emit(self, txt: str):
        indent = self._level * "    "
        line = indent + txt
        print(line, file=self._f)
