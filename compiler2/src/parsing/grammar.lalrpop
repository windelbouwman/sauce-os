
use super::{ast, LexicalError, Location};
use super::token::Token;


grammar;

pub Program: ast::Program = {
    <docstring:(String Newline)?>
    <imports:Import*>
    <definitions:Definition*>
    => {
        let docstring = docstring.map(|d| d.0);
        ast::Program {
            docstring,
            path: Default::default(),
            name: Default::default(),
            imports,
            definitions
        }
    }
};

Import: ast::Import = {
    <location:@L> "import" <modname:Identifier> Newline => {
        ast::Import::Import {
            location,
            modname
        }
    },
    <location:@L> "from" <modname:Identifier> "import" <names:Comma<Identifier>> Newline => {
        ast::Import::ImportFrom {
            location,
            modname,
            names
        }
    },
};

Definition: ast::Definition = {
    StructDef,
    ClassDef,
    EnumDef,
    <func:FunctionDef> => {
        ast::Definition::Function(func)
    },
};

EnumDef: ast::Definition = {
    "enum" <location:@L> <type_parameters:TypeVars?> <name:Identifier> ":" Newline
    Indent <options:EnumDefOption+> Dedent => {
        let type_parameters = type_parameters.unwrap_or_default();

        ast::Definition::Enum(ast::EnumDef {
            name: name.clone(),
            location: location.clone(),
            type_parameters,
            options,
        })
    }
};

EnumDefOption: ast::EnumDefOption = {
    <location:@L> <name:Identifier> Newline => {
        ast::EnumDefOption {
            name,
            location,
            data: vec![],
        }
    },
    <location:@L> <name:Identifier> "(" <data:Comma<Type>> ")" Newline => {
        ast::EnumDefOption {
            name,
            location,
            data,
        }        
    },
};

StructDef: ast::Definition = {
    "struct" <location:@L> <type_parameters:TypeVars?> <name:Identifier> ":" Newline
    Indent <fields:StructDefField+> Dedent => {
        let type_parameters = type_parameters.unwrap_or_default();

        ast::Definition::Struct(ast::StructDef {
            location: location.clone(),
            name: name.clone(),
            type_parameters,
            fields,
        })
    }
};

ClassDef: ast::Definition = {
    "class" <location:@L> <type_parameters:TypeVars?> <name:Identifier> ":" Newline
    Indent
    <fields:VariableDef+>
    <methods:FunctionDef+>
    Dedent => {
        let type_parameters = type_parameters.unwrap_or_default();

        ast::Definition::Class(ast::ClassDef {
            name: name.clone(),
            location: location.clone(),
            type_parameters,
            fields,
            methods,
        })
    }
};

VariableDef: ast::VariableDef = {
    "var" <location:@L> <name:Identifier> ":" <typ:Type> "=" <value:Expression> Newline => {
        ast::VariableDef {
            name,
            location,
            typ,
            value,
        }
    }
};

TypeVars: Vec<ast::TypeVar> = {
    "<" <typevars:Comma<TypeVar>> ">" => typevars,
};

TypeVar: ast::TypeVar = {
    <location:@L> <name:Identifier> => {
        ast::TypeVar {
            location,
            name
        }
    }
};

StructDefField: ast::StructDefField = {
    <location:@L> <name:Identifier> ":" <typ:Type> Newline => {
        ast::StructDefField {
            location,
            name,
            typ
        }
    }
};

FunctionDef: ast::FunctionDef = {
    <public:"pub"?> <location:@L> "fn" <name:Identifier>
    <signature:FunctionSignature> ":"
    Newline <body:Block> => {
        let public = public.is_some();
        ast::FunctionDef {
            location,
            name,
            public,
            signature,
            body
        }
    }
};

Parameter: ast::Parameter = {
    <location:@L> <name:Identifier> ":" <typ:Type> => {
        ast::Parameter {
            location,
            name,
            typ,
        }
    }
};

Statement: ast::Statement = {
    <location:@L> "if" <condition:Condition> ":" Newline <if_true:Block> <if_false:("else" ":" Newline Block)?> => {
        let if_false = if_false.map(|e|e.3);
        ast::Statement {
            location,
            kind: ast::StatementKind::If {
                condition,
                if_true,
                if_false,
            }
        }
    },
    <location:@L> "let" <mutable:"mut"?> <name:Identifier> <type_hint:(":" Type)?> "=" <value:BlockExpression> => {
        let mutable: bool = mutable.is_some();
        let type_hint = type_hint.map(|h| h.1);
        ast::Statement {
            location,
            kind: ast::StatementKind::Let {
                name,
                mutable,
                type_hint,
                value,
            }
        }
    },
    <location:@L> "match" <value:Expression> ":" Newline
    Indent <arms:MatchArm+> Dedent => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Match {
                value,
                arms,
            }
        }
    },
    <location:@L> "case" <value:Expression> ":" Newline
    Indent <arms:CaseArm+> Dedent => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Case {
                value,
                arms,
            }
        }
    },
    <location:@L> "switch" <value:Expression> ":" Newline
    Indent
    <arms:SwitchArm+>
    Dedent
    "else" ":" Newline <default:Block>
    => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Switch {
                value,
                arms,
                default,
            }
        }
    },
    <target:Expression> <location:@L> "=" <value:Expression> Newline => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Assignment {
                target,
                value,
            }
        }
    },
    <location:@L> "while" <condition:Condition> ":" Newline <body:Block> => {
        ast::Statement {
            location,
            kind: ast::StatementKind::While {
                condition,
                body,
            }
        }
    },
    <location:@L> "for" <name:Identifier> "in" <it:Expression> ":" Newline <body:Block> => {
        ast::Statement {
            location,
            kind: ast::StatementKind::For {
                name,
                it,
                body,
            }
        }
    },
    <location:@L> "loop" ":" Newline <body:Block> => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Loop {
                body,
            }
        }
    },
    <location:@L> "return" <value:Expression?> Newline => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Return { value }
        }
    },
    <location:@L> "break" Newline => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Break
        }
    },
    <location:@L> "continue" Newline => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Continue
        }
    },
    <location:@L> "pass" Newline => {
        ast::Statement {
            location,
            kind: ast::StatementKind::Pass
        }
    },
    <e:Expression> Newline => {
        ast::Statement {
            location: e.location.clone(),
            kind: ast::StatementKind::Expression(e)
        }
    },
};

MatchArm: ast::MatchArm = {
    <location:@L> <pattern:Expression> ":" Newline <body:Block> => {
        ast::MatchArm {
            location,
            pattern,
            body,
        }
    }
};

CaseArm: ast::CaseArm = {
    <location:@L> <variant:Identifier> <arguments:("(" Comma<Identifier> ")")?> ":" Newline <body:Block> => {
        let arguments = arguments.map(|a| a.1).unwrap_or(vec![]);
        ast::CaseArm {
            location,
            variant,
            arguments,
            body,
        }
    }
};

SwitchArm: ast::SwitchArm = {
    <location:@L> <value:Expression> ":" Newline <body:Block> => {
        ast::SwitchArm {
            location,
            value,
            body,
        }
    }
};

Block: ast::Block = {
    Indent <statements:Statement+> Dedent => statements
};

// An expression which can also be a struct literal
// using ':' and a block of fields
BlockExpression: ast::Expression = {
    // TODO: should be able to use Condition below??
    <value:Expression> Newline => value,
    <typ:Expression> <location:@L> ":" Newline
    Indent <fields:LinesOf<LabeledField>> Dedent => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::ObjectInitializer { typ: Box::new(typ), fields }
        }
    }
};

Condition: ast::Expression = {
    OrTest,
};

OrTest: ast::Expression = {
    <lhs:OrTest> <location:@L> "or" <rhs:AndTest> => {
        let op = ast::BinaryOperator::Logic(ast::LogicOperator::Or);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    AndTest,
};

AndTest: ast::Expression = {
    <lhs:AndTest> <location:@L> "and" <rhs:Comparison> => {
        let op = ast::BinaryOperator::Logic(ast::LogicOperator::And);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    Comparison,
};

Comparison: ast::Expression = {
    <lhs:Expression> <location:@L> <op:CmpOp> <rhs:Expression> => {
        let op = ast::BinaryOperator::Comparison(op);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    }
};

CmpOp: ast::ComparisonOperator = {
    "<" => ast::ComparisonOperator::Lt,
    "<=" => ast::ComparisonOperator::LtEqual,
    ">" => ast::ComparisonOperator::Gt,
    ">=" => ast::ComparisonOperator::GtEqual,
    "==" => ast::ComparisonOperator::Equal,
    "!=" => ast::ComparisonOperator::NotEqual,
};

Expression: ast::Expression = {
    ArithmaticExpression,
};

ArithmaticExpression: ast::Expression = {
    BitwiseOr
};

BitwiseOr: ast::Expression = {
    <lhs:BitwiseOr> <location:@L> "|" <rhs:BitwiseXor> => {
        let op = ast::BinaryOperator::Bit(ast::BitOperator::Or);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    BitwiseXor
};

BitwiseXor: ast::Expression = {
    <lhs:BitwiseXor> <location:@L> "^" <rhs:BitwiseAnd> => {
        let op = ast::BinaryOperator::Bit(ast::BitOperator::Xor);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    BitwiseAnd
};

BitwiseAnd: ast::Expression = {
    <lhs:BitwiseAnd> <location:@L> "&" <rhs:ShiftExpression> => {
        let op = ast::BinaryOperator::Bit(ast::BitOperator::And);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    ShiftExpression
};

ShiftExpression: ast::Expression = {
    <lhs:ShiftExpression> <location:@L> <op:ShiftOp> <rhs:Sum> => {
        let op = ast::BinaryOperator::Bit(op);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    Sum,
};

ShiftOp: ast::BitOperator = {
    "shl" => ast::BitOperator::ShiftLeft,
    "shr" => ast::BitOperator::ShiftRight,
};

Sum: ast::Expression = {
    <lhs:Sum> <location:@L> <op:AddOp> <rhs:Term> => {
        let op = ast::BinaryOperator::Math(op);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    Term,
};

AddOp: ast::MathOperator = {
    "+" => ast::MathOperator::Add,
    "-" => ast::MathOperator::Sub,
};

Term: ast::Expression = {
    <lhs:Term> <location:@L> <op:MulOp> <rhs:Atom2> => {
        let op = ast::BinaryOperator::Math(op);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Binop { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }
        }
    },
    Atom2,
};

MulOp: ast::MathOperator = {
    "*" => ast::MathOperator::Mul,
    "/" => ast::MathOperator::Div,
};

Atom2: ast::Expression = {
    Atom,
    <location:@L> <callee:Atom2> "(" <arguments:Comma<Expression>> ")" => {
        let callee = Box::new(callee);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Call {
                callee,
                arguments
            }
        }
    },
    <location:@L> <base:Atom2> "[" <indici:Comma<Expression>> "]" => {
        let base = Box::new(base);
        ast::Expression {
            location,
            kind: ast::ExpressionKind::ArrayIndex {
                base,
                indici
            }
        }
    },
    <base:Atom2> <location:@L> "." <attr:Identifier> => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::GetAttr {
                base: Box::new(base),
                attr
            }
        }
    },
};

Atom: ast::Expression = {
    Literal,
    <location:@L> "[" <values:Comma<Expression>> "]" => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::ListLiteral(values),
        }
    },
    <location:@L> <obj:ObjRef> => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Object(obj)
        }
    },
    "(" <expr:Expression> ")" => expr,
    // TODO: should we allow types in expressions?
    // <t:Type> => t,
};

Literal: ast::Expression = {
    <location:@L> "true" => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Literal(ast::Literal::Bool(true))
        }
    },
    <location:@L> "false" => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Literal(ast::Literal::Bool(false))
        }
    },
    <location:@L> <s:String> => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Literal(ast::Literal::String(s))
        }
    },
    <location:@L> <n:Number> => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Literal(ast::Literal::Integer(n))
        }
    },
    <location:@L> <n:FloatingPoint> => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::Literal(ast::Literal::Float(n))
        }
    },
};

FunctionSignature: ast::FunctionSignature = {
    "(" <parameters:Comma<Parameter>> ")" <return_type:("->" Type)?> => {
        let return_type = return_type.map(|r| r.1);

        ast::FunctionSignature {
            parameters,
            return_type
        }
    }
};

Type: ast::Expression = {
    <location:@L> "fn" <signature:FunctionSignature> => {
        ast::Expression {
            location,
            kind: ast::ExpressionKind::FunctionType(Box::new(signature)),
        }
    },
    Expression,
};

// References to named and scoped objects:
ObjRef: ast::ObjRef = {
    <location:@L> <name:Identifier> => {
        ast::ObjRef::Name {
            location,
            name
        }
    },
    <base:ObjRef> <location:@L> "::" <member:Identifier> => {
        ast::ObjRef::Inner {
            location,
            base: Box::new(base),
            member
        }
    },
};



LabeledField: ast::LabeledField = {
    <location:@L> <name:Identifier> ":" <value:Expression> => {
        ast::LabeledField {
            location,
            name,
            value
        }
    }
};

#[inline]
Comma<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};

#[inline]
LinesOf<T>: Vec<T> = {
    <items: (<T> Newline)+> => items
};

extern {
    type Location = Location;
    type Error = LexicalError;

    enum Token {
        Number => Token::Number { value: <i64> },
        FloatingPoint => Token::FloatingPoint { value: <f64> },
        String => Token::String { value: <String> },
        Identifier => Token::Identifier { value: <String> },
        Indent => Token::Indent,
        Dedent => Token::Dedent,
        Newline => Token::Newline,
        "and" => Token::KeywordAnd,
        "break" => Token::KeywordBreak,
        "case" => Token::KeywordCase,
        "class" => Token::KeywordClass,
        "continue" => Token::KeywordContinue,
        "default" => Token::KeywordDefault,
        "else" => Token::KeywordElse,
        "enum" => Token::KeywordEnum,
        "false" => Token::KeywordFalse,
        "fn" => Token::KeywordFn,
        "for" => Token::KeywordFor,
        "from" => Token::KeywordFrom,
        "if" => Token::KeywordIf,
        "import" => Token::KeywordImport,
        "in" => Token::KeywordIn,
        "let" => Token::KeywordLet,
        "loop" => Token::KeywordLoop,
        "match" => Token::KeywordMatch,
        "mut" => Token::KeywordMut,
        "or" => Token::KeywordOr,
        "pass" => Token::KeywordPass,
        "pub" => Token::KeywordPub,
        "return" => Token::KeywordReturn,
        "struct" => Token::KeywordStruct,
        "switch" => Token::KeywordSwitch,
        "true" => Token::KeywordTrue,
        "var" => Token::KeywordVar,
        "while" => Token::KeywordWhile,
        "(" => Token::OpeningParenthesis,
        ")" => Token::ClosingParenthesis,
        "{" => Token::OpeningBrace,
        "}" => Token::ClosingBrace,
        "[" => Token::OpeningBracket,
        "]" => Token::ClosingBracket,
        ":" => Token::Colon,
        "::" => Token::DoubleColon,
        "," => Token::Comma,
        "." => Token::Dot,
        "->" => Token::Arrow,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "==" => Token::DoubleEqual,
        "=" => Token::Equal,
        "!=" => Token::NotEqual,
        "*" => Token::Asterix,
        "/" => Token::Slash,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "shl" => Token::ShiftLeft,
        "shr" => Token::ShiftRight,
        "|" => Token::Pipe,
        "&" => Token::Ampersand,
        "^" => Token::Hat,
    }
} 

